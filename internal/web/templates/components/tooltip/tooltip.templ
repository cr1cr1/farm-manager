package tooltip

import (
	"fmt"
	"github.com/coreycole/datastarui/utils"
)

// TooltipSignals defines the state for a tooltip
type TooltipSignals struct {
	Open        bool   `json:"open"`
	ShowTimeout string `json:"showTimeout"` // Timeout ID for showing
	HideTimeout string `json:"hideTimeout"` // Timeout ID for hiding
	TouchHeld   bool   `json:"touchHeld"`   // Whether touch is being held
	TouchTimer  string `json:"touchTimer"`  // Timeout ID for touch-and-hold
}

// TooltipTrigger creates a trigger for the tooltip that wraps any element
templ TooltipTrigger(args TooltipTriggerArgs) {
	{{
		// Create tooltip handler for clean expressions
		tooltipHandler := NewTooltipHandler(args.TooltipID)

		// Get delay from args or use default
		delayDuration := args.DelayDuration
		if delayDuration == 0 {
			delayDuration = 700 // Default delay
		}

		// Build handlers
		showHandler := tooltipHandler.BuildShowHandler(delayDuration)
		hideHandler := tooltipHandler.BuildHideHandler()
		
		// Build touch handlers for mobile support
		touchStartHandler := tooltipHandler.BuildTouchStartHandler(500) // 500ms touch-and-hold
		touchEndHandler := tooltipHandler.BuildTouchEndHandler()
		
		// Initialize signals for the tooltip
		signals := utils.Signals(args.TooltipID, TooltipSignals{
			Open:        false,
			ShowTimeout: "",
			HideTimeout: "",
			TouchHeld:   false,
			TouchTimer:  "",
		})
		
		// Use TooltipID as anchor name (shared with content)
		anchorStyle := tooltipHandler.BuildAnchorStyle(args.TooltipID)

		// Build style attribute
		style := "cursor: pointer;"
		if anchorStyle != "" {
			style += " " + anchorStyle
		}
	}}
	<div
		id={ args.ID }
		data-signals={ signals.DataSignals }
		data-tooltip-id={ args.TooltipID }
		data-on-mouseenter={ showHandler }
		data-on-mouseleave={ hideHandler }
		data-on-focus={ showHandler }
		data-on-blur={ hideHandler }
		data-on-touchstart={ touchStartHandler }
		data-on-touchend={ touchEndHandler }
		tabindex="0"
		if style != "" {
			style={ style }
		}
		class={ args.Class }
		{ args.Attributes... }
	>
		{ children... }
	</div>
}

// TooltipContent creates the tooltip content panel (exactly like PopoverContent)
templ TooltipContent(args TooltipContentArgs) {
	{{
		contentClasses := TooltipContentVariants(args)

		// Create tooltip handler for clean expressions
		tooltipHandler := NewTooltipHandler(args.ID)

		// Build click-outside handler to dismiss tooltip on mobile
		// Use data attribute to identify tooltip triggers
		triggerSelector := fmt.Sprintf("[data-tooltip-id=\"%s\"]", args.ID)
		clickOutsideHandler := tooltipHandler.BuildClickOutsideHandler(triggerSelector)

		// Generate positioning styles (same as popover)
		positioningStyle := ""

		if args.UseAnchor {
			// Use content ID as position anchor (matches trigger's TooltipID)
			positioningStyle = "position: absolute; " + tooltipHandler.BuildPositionAnchorStyle(args.ID) + "; z-index: 50; "

			if args.Side != "" || args.Align != "" {
				sideOffset := args.SideOffset
				if sideOffset == 0 {
					sideOffset = 4 // default offset for tooltips (smaller than popover)
				}
				anchorCSS := utils.GetAnchorPosition(args.Side, args.Align, sideOffset)
				positioningStyle += anchorCSS + ";"
			}
		} else {
			// Default positioning without anchor
			positioningStyle = "position: absolute; z-index: 50;"
		}

		// Add anchor-positioned class if using anchor positioning
		if args.UseAnchor {
			contentClasses += " anchor-positioned"
		}
	}}
	<div
		id={ args.ID }
		popover="auto"
		class={ contentClasses }
		style={ positioningStyle }
		data-on-click__outside={ clickOutsideHandler }
		{ args.Attributes... }
	>
		{ children... }
	</div>
}
